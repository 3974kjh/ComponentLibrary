/// <reference types="svelte" />
import type { Writable } from 'svelte/store';
type BodyMethods = 'arrayBuffer' | 'blob' | 'formData' | 'json' | 'text';
type ResponseMapping = {
    [mimeType: string]: (res: Response) => Promise<any>;
};
export type FetchConfig<TData = any> = {
    options?: () => RequestInit;
    disabled?: boolean;
    force?: boolean;
    as?: 'auto' | BodyMethods | ((response: Response) => Promise<any>) | ResponseMapping;
    onDataChange?: (newData: TData, data: TData) => any;
    onResponseChange?: (response: Response, state: FetchState) => any;
    once?: boolean;
    /**
     * Writable store used to track all errors.  Useful to handle all errors consistently.  Typically passed via initFetchClient
     */
    errors?: Writable<any[]>;
    /**
     * Do not pass errors up to context
     */
    suppressErrors?: boolean;
};
export declare function initFetchClient(config: FetchConfig<any>): void;
export type FetchState = {
    loading: boolean | undefined;
    data: any;
    error: any;
    request: {
        url: string;
        options: RequestInit;
    };
    response: any;
};
export declare const defaultOptions: RequestInit;
export default function fetchStore(): {
    subscribe: (this: void, run: import("svelte/store").Subscriber<FetchState>, invalidate?: import("svelte/store").Invalidator<FetchState> | undefined) => import("svelte/store").Unsubscriber;
    fetch: (url: string, config?: FetchConfig) => {
        subscribe: (this: void, run: import("svelte/store").Subscriber<FetchState>, invalidate?: import("svelte/store").Invalidator<FetchState> | undefined) => import("svelte/store").Unsubscriber;
    } | undefined;
    refresh(): void;
    clear(): void;
    fetchConfig: Writable<{
        url: string;
        config?: FetchConfig<any> | undefined;
    }>;
};
export {};
