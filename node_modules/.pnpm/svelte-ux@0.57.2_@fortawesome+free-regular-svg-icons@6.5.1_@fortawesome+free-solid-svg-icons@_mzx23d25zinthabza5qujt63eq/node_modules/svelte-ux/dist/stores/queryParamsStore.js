import { derived, get } from 'svelte/store';
import { isEqual } from 'lodash-es';
import * as Serialize from '../utils/serialize';
import rollup from '../utils/rollup';
/**
 * Set a single querystring param
 */
export function queryParamStore(props) {
    const store = derived(props.page, ($page) => {
        const values = $page.url.searchParams.getAll(props.name);
        return decodeParam(values, props.paramType) ?? props.default;
    });
    /**
     * Apply new value to existing `URLSearchParams`
     */
    function apply(params, newValue) {
        //  Do not update querystring with initialValue..
        if (typeof window !== 'undefined') {
            applyParam(params, props.name, newValue, props.default, props.paramType);
        }
    }
    return {
        subscribe: store.subscribe,
        set: (value) => {
            if (props.goto === undefined) {
                console.error('`goto` must be passed to allow setting URL via store');
            }
            else {
                const url = new URL(window.location.href);
                apply(url.searchParams, value);
                props.goto(url, get(props.page));
            }
        },
        apply,
    };
}
/**
 * Set all query string params based on object.  Each object property represents a single query param
 */
export function queryParamsStore(props) {
    const store = derived(props.page, ($page) => {
        const state = { ...props.defaults };
        // Group by key
        const groupedParams = rollup([...$page.url.searchParams], (items) => items.map((x) => x[1]), [([key, value]) => key]);
        for (const [key, values] of groupedParams) {
            const paramType = typeof props.paramTypes === 'function'
                ? props.paramTypes(key)
                : props.paramTypes?.[key];
            state[key.toString()] = decodeParam(values, paramType);
        }
        return state;
    });
    /**
     * Create new `URLSearchParams` from values and paramTypes mapping
     */
    function createParams(newValues) {
        //  Do not update querystring with initialValue..
        if (typeof window !== 'undefined') {
            const params = new URLSearchParams(); // queryParamsStore controls full params so start fresh
            if (newValues != null) {
                Object.entries(newValues).forEach(([key, value]) => {
                    const paramType = typeof props.paramTypes === 'function'
                        ? props.paramTypes(key)
                        : props.paramTypes?.[key];
                    applyParam(params, key, value, props.defaults?.[key], paramType);
                });
            }
            return params;
        }
    }
    function createUrl(newValues) {
        if (typeof window !== 'undefined') {
            const params = createParams(newValues);
            const url = new URL(window.location.href);
            url.search = params?.toString() ?? '';
            return url;
        }
    }
    return {
        subscribe: store.subscribe,
        set: (values) => {
            if (props.goto === undefined) {
                console.error('`goto` must be passed to allow setting URL via store');
            }
            else {
                const url = createUrl(values);
                if (url) {
                    props.goto(url, get(props.page));
                }
            }
        },
        createParams,
        createUrl,
    };
}
function applyParam(params, key, value, defaultValue, paramType) {
    if (isEqual(defaultValue, value) ||
        value == null ||
        (Array.isArray(value) && value.length === 0)) {
        params.delete(key);
    }
    else if (paramType) {
        const config = getParamConfig(paramType);
        if (config) {
            // TODO: Add `ParamType` which calls `params.append()` for each value instead of encoding together
            params.set(key, config.encode(value) ?? '');
        }
    }
}
function decodeParam(values, paramType) {
    if (paramType) {
        const config = getParamConfig(paramType);
        return config.decode(values);
    }
    else {
        return null;
    }
}
export function getParamConfig(paramType) {
    switch (paramType) {
        case 'string':
            return {
                encode: Serialize.encodeString,
                decode: Serialize.decodeString,
            };
        case 'string[]':
            return {
                encode: Serialize.encodeDelimitedArray,
                decode: Serialize.decodeDelimitedArray,
            };
        case 'number':
            return {
                encode: Serialize.encodeNumber,
                decode: Serialize.decodeNumber,
            };
        case 'number[]':
            return {
                encode: Serialize.encodeDelimitedNumericArray,
                decode: Serialize.decodeDelimitedNumericArray,
            };
        case 'boolean':
            return {
                encode: Serialize.encodeBoolean,
                decode: Serialize.decodeBoolean,
            };
        case 'date':
            return {
                encode: Serialize.encodeDate,
                decode: Serialize.decodeDate,
            };
        case 'datetime':
            return {
                encode: Serialize.encodeDateTime,
                decode: Serialize.decodeDateTime,
            };
        case 'json':
            return {
                encode: Serialize.encodeJson,
                decode: Serialize.decodeJson,
            };
        case 'object':
            return {
                encode: Serialize.encodeObject,
                decode: Serialize.decodeObject,
            };
        default:
            throw new Error('No param config found');
    }
}
/**
 *
 * @param params
 * @returns
 */
function stringify(params) {
    // Use `encodeURIComponent` instead of `params.toString()` as is more lenient (doesn't encode `(` or `)` where are used )
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent
    // https://stackoverflow.com/a/62969380/191902
    return Object.entries(params)
        .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`)
        .join('&');
}
